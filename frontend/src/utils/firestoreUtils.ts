import { Timestamp, collection, doc, getDoc, setDoc, addDoc, updateDoc, deleteDoc, query, where, orderBy, serverTimestamp, getDocs, writeBatch, Unsubscribe, onSnapshot, DocumentReference, Query } from "firebase/firestore";
import { firebaseApp } from "app"; // Use the initialized app
import { getFirestore } from "firebase/firestore";

// Initialize Firestore
const db = getFirestore(firebaseApp);

// --- Interfaces ---

/**
 * Represents the main user document in Firestore.
 */
export interface UserProfile {
  id?: string; // User ID (same as auth uid)
  email: string | null;
  displayName: string | null;
  createdAt: Timestamp;
  // Add other profile fields as needed (e.g., preferences)
}

/**
 * Represents a habit tracked by the user.
 */
export interface Habit {
  id?: string; // Automatically generated by Firestore
  userId: string; // Keep track of who owns the habit
  name: string; // Name of the habit (e.g., "Meditate", "Drink Water")
  createdAt: Timestamp; // When the habit was created
  isActive: boolean; // If the habit is currently active

  // --- Goal Settings ---
  goalType: "completion" | "quantity" | "duration_minutes"; // Type of goal
  goalValue: number | null; // Target value (e.g., 8 for quantity, 10 for duration) - null if type is 'completion'

  // --- Streak Tracking ---
  currentStreak: number; // Current consecutive days completed
  longestStreak: number; // Longest streak ever achieved
  lastCompletedDate: Timestamp | null; // Timestamp of the last completion (to calculate streak)
}

/**
 * Represents daily progress towards a specific habit, especially for non-completion goals.
 * Stored as a sub-collection under each habit document.
 */
export interface HabitProgress {
    id?: string; // Can use date string YYYY-MM-DD as the ID
    date: Timestamp; // The specific date of the progress entry
    valueAchieved: number; // How much was done (e.g., 5 glasses of water, 15 minutes meditation)
    goalMet: boolean; // Was the goal for this day met?
    linkedMoodEntryId?: string; // Optional: ID of mood entry logged around this completion
}


/**
 * Represents a mood entry logged by the user.
 */
export interface MoodEntry {
  id?: string; // Automatically generated by Firestore
  userId: string; // Keep track of who owns the mood entry
  timestamp: Timestamp;
  moodEmoji: string;
  notes?: string;
  linkedHabitIds?: string[]; // Optional: List of habit IDs completed around this time
}

// --- Collection/Document References ---

/**
 * Gets a reference to the main 'users' collection.
 */
export const getUsersCollectionRef = () => collection(db, "users");

/**
 * Gets a reference to a specific user's document.
 * @param userId - The user's ID.
 * @returns DocumentReference
 */
export const getUserDocRef = (userId: string) => doc(db, "users", userId);

/**
 * Gets a reference to the 'habits' subcollection for a specific user.
 * @param userId - The user's ID.
 * @returns CollectionReference
 */
export const getHabitsCollectionRef = (userId: string) =>
  collection(getUserDocRef(userId), "habits");

/**
 * Gets a reference to a specific habit document.
 * @param userId - The user's ID.
 * @param habitId - The habit's ID.
 * @returns DocumentReference
 */
export const getHabitDocRef = (userId: string, habitId: string) =>
  doc(getHabitsCollectionRef(userId), habitId);

/**
 * Gets a reference to the 'progress' subcollection for a specific habit.
 * @param userId - The user's ID.
 * @param habitId - The habit's ID.
 * @returns CollectionReference
 */
export const getHabitProgressCollectionRef = (userId: string, habitId: string) =>
    collection(getHabitDocRef(userId, habitId), "progress");

/**
 * Gets a reference to a specific habit progress document (using date as ID).
 * @param userId - The user's ID.
 * @param habitId - The habit's ID.
 * @param dateString - The date string in "YYYY-MM-DD" format.
 * @returns DocumentReference
 */
export const getHabitProgressDocRef = (userId: string, habitId: string, dateString: string) =>
    doc(getHabitProgressCollectionRef(userId, habitId), dateString);


/**
 * Gets a reference to the 'moodEntries' subcollection for a specific user.
 * @param userId - The user's ID.
 * @returns CollectionReference
 */
export const getMoodEntriesCollectionRef = (userId: string) =>
  collection(getUserDocRef(userId), "moodEntries");

/**
 * Gets a reference to a specific mood entry document.
 * @param userId - The user's ID.
 * @param moodEntryId - The mood entry's ID.
 * @returns DocumentReference
 */
export const getMoodEntryDocRef = (userId: string, moodEntryId: string) =>
    doc(getMoodEntriesCollectionRef(userId), moodEntryId);


// --- Firestore Operations ---

// ... (Keep existing functions like getUserProfile, createUserProfile, etc.)

// --- Habit Operations ---

/**
 * Adds a new habit to the user's subcollection with default values.
 * @param userId - The user's ID.
 * @param habitData - The basic habit data (name, goalType, goalValue).
 * @returns Promise<DocumentReference | null> - The reference to the new document or null on error.
 */
export const addHabit = async (
  userId: string,
  habitData: Pick<Habit, "name" | "goalType" | "goalValue">
): Promise<DocumentReference | null> => {
  try {
    const fullHabitData: Omit<Habit, "id"> = {
      ...habitData,
      userId: userId,
      createdAt: serverTimestamp() as Timestamp,
      isActive: true,
      currentStreak: 0,
      longestStreak: 0,
      lastCompletedDate: null,
      // Ensure goalValue is null if goalType is 'completion'
      goalValue: habitData.goalType === 'completion' ? null : habitData.goalValue,
    };
    const docRef = await addDoc(getHabitsCollectionRef(userId), fullHabitData);
    console.log("Habit added with ID: ", docRef.id);
    return docRef;
  } catch (error) {
    console.error("Error adding habit: ", error);
    return null;
  }
};

/**
 * Updates an existing habit document.
 * @param userId - The user's ID.
 * @param habitId - The habit's ID.
 * @param updates - An object containing the fields to update.
 * @returns Promise<void>
 */
export const updateHabit = async (
  userId: string,
  habitId: string,
  updates: Partial<Habit>
): Promise<void> => {
  try {
    const habitRef = getHabitDocRef(userId, habitId);
    await updateDoc(habitRef, updates);
    console.log("Habit updated: ", habitId);
  } catch (error) {
    console.error("Error updating habit: ", error);
  }
};

/**
 * Deletes a habit document and its progress subcollection.
 * @param userId - The user's ID.
 * @param habitId - The habit's ID.
 * @returns Promise<void>
 */
export const deleteHabit = async (userId: string, habitId: string): Promise<void> => {
    try {
        const habitRef = getHabitDocRef(userId, habitId);
        // TODO: Delete subcollection 'progress' - requires careful implementation, potentially a cloud function for safety/completeness
        // For now, just delete the main habit doc
        await deleteDoc(habitRef);
        console.log("Habit deleted: ", habitId);
    } catch (error) {
        console.error("Error deleting habit: ", error);
    }
};

/**
 * Toggles the completion status for a specific day, updates progress, and recalculates streak.
 * This function becomes more complex with different goal types.
 * Needs careful implementation based on goalType and goalValue.
 *
 * @param userId The user's ID.
 * @param habitId The habit's ID.
 * @param date The date for which to toggle completion (defaults to today).
 * @param achievedValue Optional value for quantity/duration goals.
 * @returns Promise<void>
 */
export const toggleHabitCompletion = async (
    userId: string,
    habitId: string,
    date: Date = new Date(),
    achievedValue?: number
): Promise<void> => {
    const habitRef = getHabitDocRef(userId, habitId);
    const dateString = date.toISOString().split('T')[0]; // Format as YYYY-MM-DD
    const progressRef = getHabitProgressDocRef(userId, habitId, dateString);

    // This requires a transaction to read habit data, check goal, update progress, and update habit streak atomically.
    // Placeholder logic - full implementation is complex.
    console.warn("toggleHabitCompletion needs full implementation with transactions for goals & streaks.");

    try {
        const habitSnap = await getDoc(habitRef);
        if (!habitSnap.exists()) {
            console.error("Habit not found for toggling completion");
            return;
        }
        const habit = habitSnap.data() as Habit;

        // --- Determine new completion state for 'completion' type habits ---
        // Note: This logic currently only correctly handles 'completion' type habits.
        // Quantity/Duration types would need a different approach, potentially adding/subtracting from progress.
        let newCompletionStatus = false;
        let updatedLastCompletedDate: Timestamp | null = null;

        if (habit.goalType === 'completion') {
            const currentCompletedDate = habit.lastCompletedDate;
            let isCurrentlyCompletedToday = false;

            if (currentCompletedDate instanceof Timestamp) {
                // Compare date parts only (YYYY-MM-DD)
                const completedDateStr = currentCompletedDate.toDate().toISOString().split('T')[0];
                isCurrentlyCompletedToday = completedDateStr === dateString;
            }

            // The desired new state is the opposite of the current state for this date
            newCompletionStatus = !isCurrentlyCompletedToday;
            updatedLastCompletedDate = newCompletionStatus ? Timestamp.fromDate(date) : null;

            console.log(`Toggling completion habit '${habit.name}'. Currently completed today: ${isCurrentlyCompletedToday}. New state: ${newCompletionStatus}`);

            // --- Update Habit Document (lastCompletedDate and potentially streaks) ---
            // TODO: Implement proper streak calculation within a transaction.
            const habitUpdateData: Partial<Habit> = {
                lastCompletedDate: updatedLastCompletedDate,
                // currentStreak: ... needs calculation based on previous day's status and newCompletionStatus
                // longestStreak: ... needs calculation
            };
            await updateDoc(habitRef, habitUpdateData);
            console.log(`Habit '${habitId}' updated. lastCompletedDate set to: ${updatedLastCompletedDate?.toDate().toISOString() ?? 'null'}. Streak logic pending.`);

            // --- Optional: Update Progress Subcollection for consistency ---
            // This helps if other parts of the app read the progress subcollection directly.
            const progressData: HabitProgress = {
                date: Timestamp.fromDate(date),
                valueAchieved: newCompletionStatus ? 1 : 0, // Represent completion as 1, non-completion as 0
                goalMet: newCompletionStatus,
            };
            // Use setDoc with merge:true to create or overwrite the progress entry for the specific date.
            await setDoc(progressRef, progressData, { merge: true });
            console.log(`Habit progress subcollection for ${dateString} updated. goalMet: ${newCompletionStatus}`);

        } else {
            console.warn(`toggleHabitCompletion currently only supports 'completion' goalType. Habit '${habit.name}' has type '${habit.goalType}'. No changes made.`);
            // For quantity/duration, we'd likely update `HabitProgress.valueAchieved`
            // and then determine `goalMet` and update `lastCompletedDate` based on that.
            // This requires a different UI interaction (e.g., logging a value).
        }

    } catch (error) {
        console.error("Error toggling habit completion: ", error);
    }
};


// --- Mood Entry Operations ---

/**
 * Adds a new mood entry to the user's subcollection.
 * @param userId - The user's ID.
 * @param moodData - The mood entry data (moodEmoji, optional notes, optional linkedHabitIds).
 * @returns Promise<DocumentReference | null> - The reference to the new document or null on error.
 */
export const addMoodEntry = async (
  userId: string,
  moodData: Pick<MoodEntry, "moodEmoji" | "notes" | "linkedHabitIds">,
): Promise<DocumentReference | null> => {
  try {
    const dataWithTimestamp: Omit<MoodEntry, "id" | "userId"> = {
      ...moodData,
      timestamp: serverTimestamp() as Timestamp,
    };
    const docRef = await addDoc(
      getMoodEntriesCollectionRef(userId),
      {
          ...dataWithTimestamp,
          userId: userId // Ensure userId is stored in the document
      }
    );
    console.log("Mood entry added with ID: ", docRef.id);
    return docRef;
  } catch (error) {
    console.error("Error adding mood entry: ", error);
    return null;
  }
};

/**
 * Updates an existing mood entry document.
 * @param userId - The user's ID.
 * @param moodEntryId - The mood entry's ID.
 * @param updates - An object containing the fields to update.
 * @returns Promise<void>
 */
export const updateMoodEntry = async (
  userId: string,
  moodEntryId: string,
  updates: Partial<MoodEntry>
): Promise<void> => {
    try {
        const moodEntryRef = getMoodEntryDocRef(userId, moodEntryId);
        await updateDoc(moodEntryRef, updates);
        console.log("Mood entry updated: ", moodEntryId);
    } catch (error) {
        console.error("Error updating mood entry: ", error);
    }
};

/**
 * Deletes a mood entry document.
 * @param userId - The user's ID.
 * @param moodEntryId - The mood entry's ID.
 * @returns Promise<void>
 */
export const deleteMoodEntry = async (userId: string, moodEntryId: string): Promise<void> => {
    try {
        const moodEntryRef = getMoodEntryDocRef(userId, moodEntryId);
        await deleteDoc(moodEntryRef);
        console.log("Mood entry deleted: ", moodEntryId);
    } catch (error) {
        console.error("Error deleting mood entry: ", error);
    }
};

// --- Listener / Subscription Functions ---

/**
 * Subscribes to real-time updates for a user's habits.
 * @param userId - The user's ID.
 * @param callback - Function to call with the updated habits array.
 * @returns Unsubscribe function.
 */
export const onHabitsUpdate = (
    userId: string,
    callback: (habits: Habit[]) => void,
    onError: (error: Error) => void
): Unsubscribe => {
    const q = query(getHabitsCollectionRef(userId), orderBy("createdAt", "desc"));

    const unsubscribe = onSnapshot(q, (querySnapshot) => {
        const habits: Habit[] = [];
        querySnapshot.forEach((doc) => {
            // Note: We might need to fetch recent progress for streak calculation here
            // or handle streak calculation primarily in toggleHabitCompletion
            habits.push({ id: doc.id, ...doc.data() } as Habit);
        });
        callback(habits);
    }, (error) => {
        console.error("Error in habits listener: ", error);
        onError(error);
    });

    return unsubscribe;
};

/**
 * Subscribes to real-time updates for a user's mood entries.
 * @param userId - The user's ID.
 * @param callback - Function to call with the updated mood entries array.
 * @returns Unsubscribe function.
 */
export const onMoodEntriesUpdate = (
    userId: string,
    callback: (moodEntries: MoodEntry[]) => void,
    onError: (error: Error) => void
): Unsubscribe => {
    const q = query(getMoodEntriesCollectionRef(userId), orderBy("timestamp", "desc"));

    const unsubscribe = onSnapshot(q, (querySnapshot) => {
        const moodEntries: MoodEntry[] = [];
        querySnapshot.forEach((doc) => {
            moodEntries.push({ id: doc.id, ...doc.data() } as MoodEntry);
        });
        callback(moodEntries);
    }, (error) => {
        console.error("Error in mood entries listener: ", error);
        onError(error);
    });

    return unsubscribe;
};

// Potentially add listener for HabitProgress if needed for visualization
